READMEIn order to interact with our program, the user will run the program and type into the command window to give user input.  The user can only type 6 possible commands into the command window: print field, print hand, attack, switch #, play # and pass. If the user does not input one of these commands, the program will prompt the user to enter a valid command.  If the user plays some of the training cards, the program will prompt the user for a number indicating which position it wants to use the training card on. Our design involves multiple abstract classes, classes and an interface. We have an abstract card class, an abstract Dueler class and an abstract Training class that both extend from the card class. The abstract Cowardly, Pure, Brave and Royal classes all extend from the abstract Dueler class.  All of the individual duelers like KingArthur or PageGalahad have their own classes that extend from their respective Cowardly, Pure, Royal or Brave classes.  All of the individual training cards extend from the abstract Training class and each have their own classes.  We also have three other classes: the Util class, Game class and Player class.  The Game class deals internally with the field and the cards. The player class deals with the more external factors like the deck and user input and output.  The Util class contains methods that parse the deck and initialize cards. We also have Communicate interface that returns the input buffered reader to be used by everything that interacts with the game state and needs input.  Our Game class implements Communicate. Our program functions by first initializing a game and the two players within that game.  Then we call the method startgame which begins the game by drawing 6 cards for each player. The method that draws the cards initializes the cards and stores them in a linked list.  The method play plays trainer cards and adds the dueler cards to each player’s field, which is stored in a 7-element array.  The 0 index of the array refers to the arena position on the field.  Methods in Game call methods from the classes in the Card class to manipulate the field. Methods in the Player class call methods from the Game class to hand the input and output side of the program. For testing, we tested all types of training cards, special power and basic functionality between Cards and classes. We extensively tested the various aspects of the game that we were unable to explicitly test by playing the game.  We intentionally created edge case scenarios while playing our game.  We also tested the REPL by playing the game. Some possible bugs could deal with null pointer exception calls that were not properly caught. There could also be bugs in the out printing of our strings since they get sent multiple places in our program. We did not choose to implement and extra features and did not collaborate with anyone else. 